#! /bin/sh

# Author:
#
#     Alberto Bursi <starshipeleven@hotmail.it>
#
# Copyright:
#
#     Alberto Bursi 2015
#
# License:
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This package is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# On Debian systems, the complete text of the GNU General
# Public License version 3 can be found in `/usr/share/common-licenses/GPL-3'.


#This script is HEAVILY commented, for the sake of easy understanding and mainteneance
#Don't think I'm patronizing, it's first and foremost because I'm sure I will forget 
#some of its arcane spells and I don't feel like wasting hours trying to understand what 
#I wrote an unspecified amount of time ago. -Alberto Bursi

#If you edit it, please comment HEAVILY what you are doing, you will thank me later.

############### USER INTERFACE FUNCTIONS

print_usage() {
	echo "folder2ram is a script-based utility that relocates the contents of a folder to RAM"
	echo "and on shutdown unmounts it safely synching the data back to the permanent storage."
	echo ""
	echo "There are five main components of folder2ram system:"
	echo "--the init scripts that do the mounting and unmounting automatically in /etc/init.d"
	echo "--the configuration and management tool in /etc/sbin/folder2ram"
	echo "--the configuration file in /etc/folder2ram/folder2ram.conf"
	echo "--the template files in /etc/folder2ram/templates"
	echo "--the folders in /var/folder2ram, the bind-mounted folders"
	echo "  they allow easy access to the original folder in permanent storage"
	echo "  since if you mount folder A on folder B you lose access to folder B"
	echo "  this trick allows access to B, allowing synching with the tmpfs at will"
	echo ""
	echo "for first startup use -configure action, then -generate, then -mountall"
	echo ""
	echo "list of actions:"
	echo ""
	echo "-generate"
	echo "::::::::::folder2ram will read the configuration file at /etc/folder2ram/folder2ram.etc"
	echo "::::::::::and generate the init scripts that are missing"
	echo ""
	echo "-clean"
	echo "::::::::::stop folder2ram and remove all folder2ram init scripts"
	echo ""
	echo "-refresh"
	echo "::::::::::delete and create again folder2ram initscripts, then start them again if they were running."
	echo "::::::::::This is called when updating and when something changes the templates."
	echo ""
	echo "-status"
	echo "::::::::::print all mountpoints and their status (mounted or unmounted)"
	echo ""
	echo "-mount /folder/path"
	echo "::::::::::folder2ram will start the init script for that particular folder,"
	echo "::::::::::if it is in the configuration file."
	echo ""
	echo "-mountall"
	echo "::::::::::folder2ram will start all initscripts of all folders in the config file"
	echo ""
	echo "-umount /folder/path"
	echo "::::::::::folder2ram will stop the init script for that particular folder,"
	echo "::::::::::if it is in the configuration file."
	echo ""
	echo "-umountall"
	echo "::::::::::folder2ram will stop all initscripts of all folders in the config file"
	echo ""
	echo "-configure"
	echo "::::::::::folder2ram will open the configuration file in a text editor"
	echo ""
	echo "-reset"
	echo "::::::::::delete all folder2ram init scripts and restore default config file"
	echo ""
}

print_usage_exit() {
    print_usage
    exit
}

#################### UTILITY FUNCTIONS CALLED BY PRIMARY FUNCTIONS

read_mount_point() {
# this reads config file at a predetemined line and extracts mount point 
# $line_number must come from outside
# blank lines and commented lines are ignored, so line_number refers only to actual mount points
# a similar function can be used to extract additional options in the future

line_number=$1 

# remove blank and commented lines with sed, get variable form outside in awk, and use it to print line at $line_number
mount_point=$( sed '/^[[:space:]]*$/d' /etc/folder2ram/folder2ram.conf | sed '/^#/d' | awk -v line="$line_number" 'NR == line {print $2}' )

# checking if mount point variable is empty, and if it is returning a keyword
if [ "x$mount_point" != "x" ]; then 
echo "$mount_point";
else
echo "no_more_mount_points";
fi

}

generate_initscript_name() {

# cleaning the mount point string to generate a initscript name that won't break anything
# basically turning /this/is/a/path into -this-is-a-path-mount_type

#initializing variables
mount_point=$1

# mount_type is hardcoded for now, will be set by something else when I implement more folder2ram options
mount_type="tmpfs" 

# field separator is set as "/" then the record separator is set as "-" , the loop prints one by one the fields
# (because I could not find a better way to get the damn "-" to be inserted properly) 
# then disables the record separators and prints the variable "mount_type" coming from outside awk (see the -v option)
clean_mount_point=$(echo "$mount_point" | awk -v mount_type="$mount_type" -F '/' '{ORS="-"; out=$1; for(i=1;i<=NF;i++){out=$i; print out}; ORS=""; print mount_type}' )

# generating the initscript name, will look like this "folder2ram-this-is-a-path-mount_type"
initscript_name="f2r$clean_mount_point"

#outputting the result
echo "$initscript_name"

}

generate_initscript() {

initscript_name=$1
initscript_path="/etc/init.d/$initscript_name"

	echo "generating $initscript_path" ;

# this reads the etc/folder2ram/templates/folder2ram_init_template
# and writes that into /etc/init.d/$initscript_name.
	cat "/etc/folder2ram/templates/folder2ram_init_template" > "$initscript_path" ;

# this sets some variables we need to be different in the initscript, by appending them to the same file
	sed -i "/# Provides: folder2ram/c\# Provides: $initscript_name" "$initscript_path" ;
	sed -i "/NAME=name/c\NAME=$initscript_name" "$initscript_path" ;
	sed -i "/DIR=dir/c\DIR=$mount_point" "$initscript_path" ;

# this marks the newly created file as executable
	chmod +x "$initscript_path" ;

# this asks insserv to generate symlinks in the appropriate runlevels
	insserv "$initscript_name" ;

}


########################## PRIMARY FUNCTIONS ################################

mount_umount_all() {

# initializing variables    
line_number=1 
start_or_stop=$1

echo "will now $start_or_stop all mountpoints"

######################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

#########################################################

############BEGINNING MAIN LOOP::::::::::::::::::::::::::::::::::::::

until [ "$mount_point" = "no_more_mount_points" ] ;  do

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

initscript_name=$(generate_initscript_name "$mount_point")

# generating a variable with full name inside, easier to manipulate
initscript_path="/etc/init.d/$initscript_name"

################FUNCTION PAYLOAD#############

if [ -x "/etc/init.d/$initscript_name" ]; then 
echo "/etc/init.d/$initscript_name" "$start_or_stop";
/etc/init.d/"$initscript_name" "$start_or_stop"
else
echo "$initscript_path init script not installed, not starting";
fi

####################################

# increasing line number
line_number=$((line_number+1))

######################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

#########################################################

###########ENDING OF MAIN LOOP::::::::::::::::::::::::::
done

}

mount_umount_mountpoint() {

# initializing variables    
specified_mount_point=$1
start_or_stop=$2

echo "will $start_or_stop the $specified_mount_point folder if it is in the list"

initscript_name=$(generate_initscript_name "$specified_mount_point")

# generating a variable with full name inside, easier to manipulate
initscript_path="/etc/init.d/$initscript_name"

################FUNCTION PAYLOAD#############

if [ -x "$initscript_path" ]; 
then ############BEGIN THEN

	echo "$initscript_path exists, starting" ;
	#starting or stopping the init script
	"$initscript_path" "$start_or_stop";

else ############BEGIN ELSE

	echo "$initscript_path not found, please add it to the config with -configure then do a -generate, then you can try again with this action" ;
fi

}

generate_initscripts() {

echo "generating all folder2ram initscripts"

# initializing variables    
line_number=1

######################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

#########################################################

############BEGINNING MAIN LOOP::::::::::::::::::::::::::::::::::::::

until [ "$mount_point" = "no_more_mount_points" ] ;  do

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

# calling another function (above) to fill the initscript name at this line number
initscript_name=$(generate_initscript_name "$mount_point")

# generating a variable with full name inside, easier to manipulate
initscript_path="/etc/init.d/$initscript_name"

###################BEGIN IF CHECK FOR SAME NAME SCRIPTS

#checking if there is another initscript with the same name, skipping to next mount point if found 
if [ -x "$initscript_path" ]; 
then ############BEGIN THEN

	echo "$initscript_path exists, skipping" ;

else ############BEGIN ELSE

	generate_initscript "$initscript_name"
	
########END IF CHECK FOR SAME NAME SCRIPT
fi

# increasing line number
line_number=$((line_number+1))

################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

########################################################

#:::::::::::ENDING OF MAIN LOOP
done


}


clean_initscripts() {

echo "stopping and deleting folder2ram initscripts"

#calling a main function to unmount all folder2ram mounts before removal
mount_umount_all stop

# initializing variables    
line_number=1

######################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

#########################################################

############BEGINNING MAIN LOOP::::::::::::::::::::::::::::::::::::::

until [ "$mount_point" = "no_more_mount_points" ] ;  do

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

# calling another function (above) to fill the initscript name at this line number
initscript_name=$(generate_initscript_name "$mount_point")

# generating a variable with full name inside, easier to manipulate
initscript_path="/etc/init.d/$initscript_name"

###################BEGIN IF

#checking if there is an initscript with the same name, skipping to next mount point if found 
if [ -e "$initscript_path" ]; 
then ############BEGIN THEN

	echo "deleting $initscript_path" ;
	insserv -r "$initscript_name" ;
	rm -f "$initscript_path" ;

else ############BEGIN ELSE and END THEN

	echo "$initscript_name not found, already deleted perhaps?" ;

########END ELSE and END IF
fi

# increasing line number
line_number=$((line_number+1))

################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

########################################################

#:::::::::::ENDING OF MAIN LOOP
done


}

refresh_initscripts() {

echo "deleting and generating again folder2ram initscripts"

# initializing variables    
line_number=1

######################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

#########################################################

############BEGINNING MAIN LOOP::::::::::::::::::::::::::::::::::::::

until [ "$mount_point" = "no_more_mount_points" ] ;  do

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

# calling another function (above) to fill the initscript name at this line number
initscript_name=$(generate_initscript_name "$mount_point")

# generating a variable with full name inside, easier to manipulate
initscript_path="/etc/init.d/$initscript_name"

################## CHECK FOR INIT SCRIPTS
#checking if there is another initscript with the same name, skipping to next mount point if not found 
if [ -x "$initscript_path" ]; 
then ############BEGIN THEN

#checking mount status
	initscript_status=$("$initscript_path" status);
#acting depending on conditions
	case "$initscript_status" in 
  "*is running*")
  	generate_initscript "$initscript_name"
  	"$initscript_path" start
    ;;
  "*is stopped*")
  	generate_initscript "$initscript_name"
    ;;
  *)
  # do nothing
  ;;
esac
	
########END IF CHECK FOR INIT SCRIPTS
fi

# increasing line number
line_number=$((line_number+1))

################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

########################################################

#:::::::::::ENDING OF MAIN LOOP
done

}

print_status() {

echo "checking what folders are mounted and what are unmounted"

#prints the status of all mounted folders

# initializing variables    
line_number=1
mount_type="tmpfs" #hardcoded for now

######################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

#########################################################

############BEGINNING MAIN LOOP::::::::::::::::::::::::::::::::::::::

until [ "$mount_point" = "no_more_mount_points" ] ;  do

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

# calling another function (above) to fill the initscript name at this line number
initscript_name=$(generate_initscript_name "$mount_point")

# generating a variable with full name inside, easier to manipulate
initscript_path="/etc/init.d/$initscript_name"

if [ -e "$initscript_path" ]; then 
"$initscript_path" status;
else
echo "$initscript_path init script not installed";
fi

# increasing line number
line_number=$((line_number+1))

################CHECKING IF THERE ARE STILL MOUNT POINTS

# calling another function (above) to fill the mount point at this line number
mount_point=$(read_mount_point "$line_number")

########################################################

#:::::::::::ENDING OF MAIN LOOP
done

}

configure(){

#if there is no config file it is generated from the template
if [ ! -e "/etc/folder2ram/folder2ram.conf" ]; then
cp "/etc/folder2ram/templates/folder2ram.conf" "/etc/folder2ram/folder2ram.conf" ;
fi

#will now ask for what text editor to use and then open it
echo "will now open the configuration file with your favourite text editor"
echo "write its name and press enter (nano, vim, gedit are the most common)"
read editor

"$editor" "/etc/folder2ram/folder2ram.conf" 

}

reset(){

echo "will now delete all folder2ram initscripts and revert all changes of folder2ram.conf"
echo "you sure you want to do that (y or n)"
read choice

case "$choice" in

Y|y|yes|Yes|YES)
#calling a function to do this job
clean_initscripts 
#removing current config and making a new one from the template
rm -f "/etc/folder2ram/folder2ram.conf" 
cp "/etc/folder2ram/templates/folder2ram.conf" "/etc/folder2ram/folder2ram.conf" 

;;

N|n|no|No|NO)
echo "ok, nevermind then"
exit

;;

*)
echo "please write y for yes or n for no"

;;

esac

}

##################END FUNCTIONS ###########################

#force='false'
#quiet='false'
#all_mountpoints='false'

#doing a root check, because folder2ram must be run as root for obvious reasons
if [ "$(id -u)" -eq 0 ]; then
echo ;
else
echo "you must run folder2ram as root, write sudo folder2ram or su folder2ram";
exit
fi

action="$1"
[ -z "$action" ] && print_usage_exit;

#shift

#while [ $# -gt 0 ]; do
#    case "$1" in
#        -a)
#            [ "$mountpoint" != "%%none%%" ] && print_usage_exit
#            mountpoint=""
#            ;;

#        -f)
#            force='true'
#            ;;

#        -q)
#            quiet='true'
#            ;;

#        *)
#            [ -z "$mountpoint" ] || [ "$mountpoint" != '%%none%%' ] && print_usage_exit
#            mountpoint="$1"
#            ;;
#    esac
#    shift
#done

#[ "$mountpoint" = "%%none%%" ] && print_usage_exit

case "$action" in
-generate)
        generate_initscripts
        ;;
-clean)
        clean_initscripts
        ;;
-refresh)
        refresh_initscripts
        ;;
-status)
        print_status
        ;;
-mount)
	read mountpoint   
	mount_umount_mountpoint "$mountpoint" start
        ;;
-mountall)
	mount_umount_all start
        ;;
-umount)
	read mountpoint
        mount_umount_mountpoint "$mountpoint" stop
        ;;
-umountall)
        mount_umount_all stop
        ;;
-configure)
        configure
        ;;
-reset)
        reset
        ;;
*)
        print_usage
        ;;
esac

exit

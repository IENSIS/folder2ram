#! /bin/sh
### BEGIN INIT INFO
# Provides: folder2ram
# X-Start-Before:	$syslog
# X-Stop-After:		$syslog
# X-Interactive:	yes
# Required-Start:
# Required-Stop:
# Default-Start:	2 3 4 5
# Default-Stop:		0 1 6
# Short-Description:	Keeps folders in RAM
# Description: Moves the contents of user-defined folders to RAM during boot
#              and keeps it there until shutdown/reboot, when it
#              copies the contents back to permanent storage.
### END INIT INFO

##### WARNING::::AUTOGENERATED::::INIT.SCRIPT::::BY::::FOLDER2RAM

# Version 1.0
# Author: Alberto Bursi <starshipeleven@hotmail.it>
#
# Slight modification of an init script called transientlog by Matteo Cortese <matteo_cortese@fastwebnet.it>
# Available from here www.debian-administration.org/article/661/A_transient_/var/log
# That page has been also saved and is available in the /doc/folder2ram folder for posterity.
#
# This modified version works with user-defined folders and is autogenerated by a configuration script, 
# while the original was hard-coded to /var/log.
# The file in the /doc/template folder contains heavier modifications so the folder2ram script can use it to
# write and deploy these initscripts automatically parsing its configuration file.
#
# transientlog borrows the base idea from ramlog by Jan Andrejkovic.
# www.tremende.com/ramlog/index.htm
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.


#This script is HEAVILY commented, for the sake of easy understanding and mainteneance
#because I'm sure I will forget some of its arcane spells and I don't feel like wasting
#hours trying to understand what I wrote an unspecified amount of time ago. -Alberto

PATH="/sbin:/bin:/usr/sbin:/usr/bin"
#################### set by external script
NAME=name 
DIR=dir
####################
DESC="ram folders" # this may be set by external script in the future
LOCKFILE="/run/lock/$NAME.lock"
#SIZE=16M this can be interesting for later, for now it stays disabled
MODE=0755

# DIRPERM is the bind mount to the directory in permanent storage
# DIR is the directory we are working with

# Read configuration variable file if it is present
#[ -r /etc/default/$NAME ] && . /etc/default/$NAME
#disabled because this script gets its config parsed by folder2ram script in sbin

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions
# added lsb-base to the dependencies, but seriously considering to dump this and do independent logging

#setting the place where all this stuff will be bind-mounted
DIRPERM="/var/folder2ram$DIR"


do_start() 
{
	# Return
	#   0 if daemon has been started
	#   1 if daemon was already running
	#   2 if daemon could not be started

	[ -f $LOCKFILE ] && return 1
	
	# Check if I'm root
	[ "$(id -u)" -eq 0 ] || return 2

	# If DIR does not exist?
	[ -d $DIR ] || return 2

	# DIRPERM either does not exist (first invocation)
	# or is empty (left from previous invocation).
	# 
	[ -d $DIRPERM ] || mkdir -p $DIRPERM || return 2

	# Mount a tmpfs over DIR.
	# The mount will shadow the current contents of DIR.
	# So, before, make a bind mount so that looking into DIRPERM
	# we'll see the current contents of DIR, which
	# will not be available anymore as soon as we mount
	# a tmpfs over it.
	#
	mount --bind $DIR $DIRPERM
#	mount -t tmpfs -o nosuid,noexec,nodev,mode=$MODE,size=$SIZE $NAME $DIR 
# original line, allows to accept options, a feature that I plan to add in the future.
	mount -t tmpfs -o nosuid,noexec,nodev,mode=$MODE $NAME $DIR
	if [ $? -eq 0 ]; then
		# Populate the tmpfs
		if cp -rfp $DIRPERM -T $DIR; then
			# Success!
			touch $LOCKFILE
			return 0
		fi

		# Something went wrong...

		# Rollback the mount
		umount -l $DIR
	fi

	# Rollback the directory mangling
	umount $DIRPERM
	
	return 2
}

do_stop() {
	# Return
	#   0 if daemon has been stopped
	#   1 if daemon was already stopped
	#   2 if daemon could not be stopped
	#   other if a failure occurred

	[ -f $LOCKFILE ] || return 1

	# Check if I am root
	[ "$(id -u)" -eq 0 ] || return 2

	# Merge back to permanent storage
	cp -rfup $DIR -T $DIRPERM

	# The following cannot fail... or can it?
	umount -l $DIR
	umount -l $DIRPERM
	rm -f $LOCKFILE
	# well, yes it can
	# being the lockfile in a tmpfs folder (/run/lock is a tmpfs folder for Debian)
	# a reboot should fix any issue anyway
	return 0
}

do_reload() {
	# Return
	#   0 if daemon has been reloaded
	#   1 if daemon was not running
	#   2 if daemon could not be reloaded

	[ -f $LOCKFILE ] || return 1
	
	# Check if I am root
	[ "$(id -u)" -eq 0 ] || return 2

	# Merge back to permanent storage
	cp -rfup $DIR -T $DIRPERM
	touch $LOCKFILE
	return 0
}

################

case "$1" in
  start)
	[ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
	do_start
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
  ;;
  stop)
	[ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
	do_stop
	case "$?" in
		0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
  ;;
  status)
  	if [ -f $LOCKFILE ]; then
		echo "$DESC is running"
	else
		echo "$DESC is stopped"
		exit 1
	fi
  ;;
  reload)
	log_daemon_msg "Reloading $DESC" "$NAME"
	do_reload
	log_end_msg $?
  ;;
  *)
	echo "Usage: $0 {start|stop|status|reload}" >&2
	exit 3
  ;;

esac

exit
